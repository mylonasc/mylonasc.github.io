---
layout: post
title: Conditional Variational Autoencoder for Wind Turbine Blade Fatigue Damage Estimation
subtitle: 
bigimg: /img/tstart288.png
tags: [CVAE, Wind Turbine Dlade, Fatigue]
---
# The project

Wind turbine fatigue estimation relies on running computationally expensive simulations. 
The inputs of the simulations (the windfield time-series) are **non-deterministic**: We have statistical models on how the wind 
behaves under different conditions, and we simulate these inputs prior to applying them to the turbine.
Also the complex dynamics (blade geometric non-linearity, pitch control etc) make the response even more difficult to approximate with an explicit model.
Finally, in order to make the most out of our simulations, we need to analyze fatigue on the cross-section/material level, and not simply on some so-called **hot-spot** locations, or manually decompose the damage in some intuitive basis (for example the standard practice in wind turbine blades is analyzing bending directions separately (which makes little sense in my opinion - for reasons I don't want to spend the energy to rant about right now..). 

This project was about training a VAE to sample from fatigue simulation outputs, that each one takes about 1h to finish (because of
 the geometric non-linearity of the blades - I'm not using a modal description for them) plus 10~20mins for the
 actual cycle-counting procedure in the cross-section level.

## Engineering application/motivation
There are several applications where this fast sampling procedure becomes relevant in wind turbines. Nevertheless, I'm focusing on one real-life potential application. 
Consider that you have only historical summary statistics on weather. You know for a fact, that you cannot completely reproduce the stress
 states on your structure, because you never sensed that data. This is what we call "aleatory" uncertainty - the uncertainty that comes 
from incomplete information on the problem.  Say that we have a way to sample a windfield that 
resembles statistically one that produces summary statistics like the ones we have available in the so-called *Supervision Control and Data Acquisition systems* aka **SCADA** . 
For me this is a black-box.

<div class="note">
<small>
  <h5>Short side-note:</h5>
  <p>The CVAE I'm using would be a great fit for this problem as well! I couldn't find real data to do that unfortunately, 
and it is sort-of a futile exercise to try this in simulated data, since they have pretty simple gaussian random field models. **UPDATE**: There is actually a publication [doing exactly that](https://arxiv.org/pdf/1911.05180.pdf) with another type of generative model (the so-called *continuous-time normalizing flow with *[Neural ODE](https://arxiv.org/abs/1806.07366) that relies on invertible transformations).
</p>
</small>
</div>

In order to have a robust estimate on fatigue, we would need to run the simulation several times **for each** SCADA reading, say 100 times (estimate on the very low side).
So in order to perform damage accumulation for 10 minutes for **one** turbine, we would need 100 * 1h = 100h worth of simulation time!
Obviously this is not going to scale well - so we need something that works on the millisecond scale instead of the 1h scale to do that!
This is where the CVAE comes into the picture: Instead of running 100 simulations, we can train a stochastic neural network that can sample the fatigue estimates.
Then we sample from the stochastic neural network and quickly obtain realistic estimates on fatigue.
Moreover, since we have some information due to the operational conditions, we train the model to reproduce the accumulated damage conditional on these conditions.

The architecture of the CVAE looks as follows during training:

![computational graph of the CVAE](/img/cvaesvg.png)

where **w** is the "conditioning" inputs and **x** is the fatigue loads of the cross-section. I considered only one cross-section, partially because visualization is much easier with one.
Deep generative models, although they perform in task that were not even imaginable a decade ago, they are quite challenging to train and test for convergence. 
In the present case, **w** is a vector of SCADA data: wind, turbullence and a parametrization of the wind velocity distribution along the height of the wind turbine.

## Training dataset and tricks
The training dataset contained 2000 fatigue estimates on ~250 finite elements. Models with varying sizes were trained with heavy regularization and annealing of the KL term and dropout rates.
The smallest well-trained model I managed to train was an encoder 50/50/50 - latent 15 - 50/50/50 decoder - all relus with dropout in-between and of course a last linear layer. I found it useful to visually monitor the latent-space and the joint distributions of the decoded samples. Luckily the main mode of fatigue damage (bending due to self-weight of the blade, in tandem with pitch variations) on the cross-section is expected and easily interpretable.
An L2 reconstruction loss and latent space $$ z $$ size from 5 to 15. Through extensive experimentation, it seems that the latent space size is not so critical. The latent space is not necessarily interpretable in the present problem. The purpose of using the VAE (or perhaps more accurately the [bayes-by-backprop](https://arxiv.org/abs/1505.05424) technique) in this problem, is not to obtain an interpretable latent space in the first place. The (reached) goal, is to quantify the uncertainty in estimates of fatigue, given only 10-minute SCADA data information.

In the way this problem is posed, it is important that there is little to no "structure"
 in the latent space. When "structure" in the approximate posterior 
$$ \mathcal{N}(\mathbf{z}|\mu(\mathbf{x}),\mu(\mathbf{w})) $$ exists, we cannot safely replace the approximate 
posterior with a diagonal Gaussian. In that case, approximating with a Gaussian will allow sampling from regions of the latent space that
decode to completely unrealistic points in the physical space. A recent paper refers to this as the *"holes"* problem of VAEs [(paper: Taming VAEs)](https://arxiv.org/abs/1810.00597).

After training the model, one may simply discard all the light gray parts in the previous figure (the *"encoder"*), sample **z** from a unit Gaussian, and include the conditioning variables on the *decoder* part. This is a visualization of samples of accumulated damage
equivalent loads from the CVAE, with one actual realization for the time-window for two cases:

![fatigue estimates](/img/tstart288.png)

![fatigue estimates](/img/tstart1200.png)


Notice the highly non-linear dependency on the inputs. Also the VAE returns results for the whole cross-section and not only for single points! 

## Conditional variational autoencoders - animation
Since this is a Conditional VAE, and we know beforehand the influencing factors we care about, is is possible to interpolate the input variables and inspect their effect on the output.
The latent space does have an effect and it is seen on the previous plots. Namely, this effect is observed in the variability on the sampled estimates of damage equivalent loads.
<video width="720" height="480" controls="controls">
  <source src="/img/conditional_VAE_for_wind_turbine_blade_Fatigue.mp4" type="video/mp4">
</video>

The animation is slow due to slow plotting.
This is part of a submitted work. The code and dataset will be released upon publication. Thank you for reading, and I hope you found that interesting! 


[//]: # " # Variational Autoencoders"
[//]: # "Variational techniques in statistics have been around for some time. Relatively recently"
